기본적으로 자바스크립트는 한 번에 하나의 작업만 동기 방식으로만 처리할 수 있다. 자바스크립트는 분명히 싱글 스레드에서 동기 방식으로 작동을 하는데 싱글 스레드 기반의 자바스크립트에서도 많은 양의 비동기 작업이 이루어지고 있다. 왜 그럴까?

### 1.5.1 싱글 스레드 자바스크립트
자바스크립트가 싱글 스레드라는 것을 무슨 뜻일까? 자바스크립트 코드의 실행이 하나의 스레드에서 순차적으로 이루어진다는 것이다. 그니까 하나의 작업이 끝나기 전까지는 뒤이은 작업이 실행되지 않는다.

그렇다면 비동기는 무엇일까? 자바스크립트에서 비동기 함수를 선언할 때 쓰는 async는 동시에 일어나지 않는 것을 의미하는 것으로 동기식과 다르게 요청한 즉시 결과가 주어지지 않는다.
```jsx
console.log(1)

setTimeout(() => {
  console.log(2)
}, 0);

setTimeout(() => {
  console.log(3)
}, 100);

console.log(4)

// 1
// 4
// 2
// 3
```

### 1.5.2 이벤트 루프란?
이벤트 루프
- 자바스크립트 런타임 외부에서 자바스크립트의 비동기 실행을 돕기 위해 만들어진 장치

##### 호출 스택과 이벤트 루프
호출 스택
- 자바스크립트에서 수행해야 할 코드나 함수를 순차적으로 담아두는 스택
```jsx
function bar() {
  console.log("bar")
}

function baz() {
  console.log("baz")
}

function foo() {
  console.log("foo")
  bar()
  baz()
}

foo()
```
이 코드는 foo를 호출하고 내부에서 bar, baz를 순차적으로 호출하는 구조인데 아래 순서로 호출 스택에 쌓이고 비워지게 된다
1. foo()가 호출 스택에 먼저 들어간다
2. foo() 내부에 console.log가 존재하니 호출 스택에 들어감
3. 2의 실행이 완료된 후에 다음 코드로 넘어감 (아직 foo()는 존재)
4. bar()가 호출 스택에 들어감
5. bar() 내부에 console.log 존재하므로 호출 스택에 들어감
6. 5의 실행이 완료된 이후에 다음 코드로 넘어감 (아직 foo(), bar()는 존재)
7. 더 이상 bar()에 남은 것이 없으니 호출 스택에서 제거된다 (아직 foo()는 존재)
8. baz()가 호출 스택에 들어감
9. baz() 내부에 console.log가 존재하니 호출 스택에 들어감
10. 9의 실행이 완료된 후 다음 코드로 넘어감 (아직 foo(), baz()는 존재)
11. 더 이상 baz()에 남은 것이 없으므로 호출 스택에서 제거됨 (아직 foo()는 존재)
12. 더 이상 foo()에 남은 것이 없으므로 호출 스택에서 제거
13. 이제 호출 스택이 완전히 비워짐 

이러한 호출 스택이 비어 있는지 여부를 확인하는 것이 바로 이벤트 루프이다
이벤트 루프는 단순히 이벤트 루프만의 단일 스레드 내부에서 이 호출 스택 내부에 수행해야할 작업이 있는지 확인하고, 수행해야 할 코드가 있다면 자바스크립트 엔진을 이용해서 실행한다

- *코드를 실행하는 것*과 *호출 스택이 비어있는지 확인하는 것* 모두 단일 스레드에서 일어남
	- 그렇기에 두 작업을 동시에 일어날 수 없고 한 스레드에서 순차적으로 일어난다

```jsx
function bar() {
  console.log("bar")
}

function baz() {
  console.log("baz")
}

function foo() {
  console.log("foo")
  setTimeout(bar(), 0) //setTimeout만 추가함
  baz()
}

foo()
```
이번이는 foo, baz, bar순으로 출력된다
1. foo()가 호출 스택에 먼저 들어감
2. foo() 내부에 console.log가 존재하므로 호출 스택에 들어감
3. 2의 실행이 완료된 이후에 다음 코드로 넘어간다 (아직 foo()는 존재)
4. setTimeout(bar(), 0)이 호출 스택에 들어간다
5. 4번에 대해 타이머 이벤트가 실행되며 태스크 큐로 들어가고, 그 대신 바로 스택에서 제거된다
6. baz()가 호출 스택에 들어간다
7. baz() 내부에 console.log가 존재하므로 호출 스택에 들어간다
8. 7의 실행이 완료된 이후에 다음 코드로 넘어감(아직 foo(), baz()는 존재)
9. 더 이상 baz()에 남은 것이 없으므로 호출 스택에서 제거됨 (아직 foo()는 존재)
10. 더 이상 foo()에 남은 것이 없으니 호출 스택에서 제거됨
11. 이제 호출 스택이 완전히 비워짐 
12. 이벤트 루프가 호출 스택이 비워져 있다는 것을 확인함 그리고 태스크 큐를 확인하니 4번에 들어갔던 내용이 있어 bar()를 호출 스택에 들여보냄
13. bar() 내부에 console.log가 존재하므로 호출 스택에 들어감
14. 13의 실행이 끝나고, 다음 코드로 넘어간다 (아직 bar() 존재)
15. 더 이상 bar()에 남은 것이 없으므로 호출 스택에서 제거됨

태스크 큐? : 실행해야 할 태스크의 집합

비동기 함수는 누가 수행할까?
자바스크립트 코드가 동기식으로 실행되는 메인 스레드가 아닌 태스크 큐가 할당되는 별도의 스레드에서 수행된다
- 즉 자바스크립트 코드 실행은 싱글 스레드에서 이루어지지만 외부 Web API등은 모두 자바크립트 코드 외부에서 실행되고 콜백이 태스크 큐로 들어간다

### 1.5.3 태스크 큐와 마이크로 태스크 큐
이벤트 루프는 하나의 마이크로 태스크 큐를 갖고 있는데, 기존의 태스크 큐와는 다른 태스크를 처리한다. (대표적인 마이크로 태스크: Promise)

- 마이크로 태스크 큐는 기존 태스크 큐보다 우선권을 가짐
```jsx
function foo() {
  console.log("foo")
}

function bar() {
  console.log("bar")
}

function baz() {
  console.log("baz")
}

setTimeout(foo, 0)

Promise.resolve().then(bar).then(baz)
```
위 코드는 bar, baz, foo 순으로 실행된다 (Promise가 우선권을 가지고 있음을 확인할 수 있음)

각 태스크에 들어가는 태표적인 작업들
- 태스크 큐 -> setTimeout, setInterval, setImmediate
- 마이크로 태스크 큐 -> process.nextTick, Promise, queueMicroTask, MutationObserver 

태스크 큐를 실행하기 전에 먼저 마이크로 태스크 큐를 실행하고, 마이크로 태스크 큐를 실행한 뒤에 렌더링이 일어난다
그리고 각 마이크로 태스크 큐 작업이 끝날 때마다 한 번씩 렌더링할 기회를 얻게 된다